{
  "title": "ADS 020 Protocols",
  "cells": [
    {
      "type": "code",
      "language": "swift",
      "data": "import UIKit\n\n// Protocols are special types that define how other types should behave under specific method & property functionalities\n// https://www.skilled.io/u/gregheo/what-the-55-swift-standard-library-protocols-taught-me\n//:## Define New Protocols\n\nprotocol FullName {\n\tvar fullName: String { get }\t\t// Read-only (gettable) property, alt { get set }\n\t// Cannot use let here, because the implementing class/struct have to set the value\n\t// If { get set }, cannot use let, must use var\n\t\n\tfunc printFullName()\t\t\t\t// Mandatory func\n}\n\nstruct Person:FullName {\n\tlet firstName: String\n\tlet lastName: String\n\t\n\tvar fullName: String {\n\t\treturn \"\\(firstName) \\(lastName)\"\n\t}\n\t\n\tfunc printFullName() {\n\t\tprint(fullName)\n\t}\n}\n//:## CustomStringConvertible\n// This protocol defines how something is supposed to be printed\n\nlet string1: String = \"Hello World\"\nprint(string1)\n\n// No problem for a basic string. Gets complicated when printing a class instance.\n\nclass Vehicle1 {\n\tvar make: String\n\tvar model: String\n\t\n\tinit(make:String,model:String) {\n\t\tself.make = make\n\t\tself.model = model\n\t}\n\t\n\n}\n\n// CustomStringConvertible has the instance property of var description: String\n\nclass Vehicle2:CustomStringConvertible {\n\tvar make: String\n\tvar model: String\n\t\n\tinit(make:String,model:String) {\n\t\tself.make = make\n\t\tself.model = model\n\t}\n\t\n\tvar description: String {\n\t\treturn \"Vehicle(make: \\(make), model: \\(model))\"\n\t}\n}\n\nlet car1 = Vehicle1(make: \"Audi\", model: \"A4\")\nprint(car1)\n\n// CustomStringConvertible protocol defines what to be printed\nlet car2 = Vehicle2(make: \"Audi\", model: \"A4\")\nprint(car2)\n//:## Equatable\n// This protocol defines the type method of how two objects are supposed to be determined as equal\nclass Employee:Equatable {\n\tlet firstName: String\n\tlet lastName: String\n\tvar jobTitle: String\n\tvar phoneNumber: String\n\t\n\tinit(firstName: String, lastName: String, jobTitle: String, phoneNumber: String) {\n\t\tself.firstName = firstName\n\t\tself.lastName = lastName\n\t\tself.jobTitle = jobTitle\n\t\tself.phoneNumber = phoneNumber\n\t}\n\t\n\tstatic func == (lhs: Employee, rhs: Employee) -> Bool {\n\t\treturn\n\t\t\tlhs.firstName == rhs.firstName &&\n\t\t\tlhs.lastName == rhs.lastName &&\n\t\t\tlhs.jobTitle == rhs.jobTitle &&\n\t\t\tlhs.phoneNumber == rhs.phoneNumber\n\t}\n}\n// Employee struct conforms to Equatable protocol, defines that all instance properties have to be equal\nlet employee1 = Employee(firstName: \"Dennis\", lastName: \"Lau\", jobTitle: \"Director\", phoneNumber: \"00000096\")\nlet employee2 = Employee(firstName: \"Dennis\", lastName: \"Lau\", jobTitle: \"Director\", phoneNumber: \"00000097\")\nlet employee3 = Employee(firstName: \"Mark\", lastName: \"Lau\", jobTitle: \"Advisor\", phoneNumber: \"00000039\")\nemployee1 == employee2 ? print(\"Same dude\") : print(\"Not same dude\")\n//:## Comparable\n// Defines how items should be compared and sorted, requires conformance to Equatable\n\nclass EmployeeSortable: Employee,Comparable {\n\tstatic func < (lhs:EmployeeSortable, rhs:EmployeeSortable) -> Bool {\n\t\treturn lhs.lastName < rhs.lastName\n\t}\n}\n\nlet employee4 = EmployeeSortable(firstName: \"Ben\", lastName: \"Atkins\", jobTitle: \"Front Desk\", phoneNumber: \"415-555-7767\")\nlet employee5 = EmployeeSortable(firstName: \"Vera\", lastName: \"Carr\", jobTitle: \"CEO\", phoneNumber: \"415-555-7768\")\nlet employee6 = EmployeeSortable(firstName: \"Daren\", lastName: \"Estrada\", jobTitle:\"Sales Lead\", phoneNumber: \"415-555-7772\")\nlet employee7 = EmployeeSortable(firstName: \"Sang\", lastName: \"Han\", jobTitle:\"Accountant\", phoneNumber: \"415-555-7771\")\nlet employee8 = EmployeeSortable(firstName: \"Grant\", lastName: \"Phelps\", jobTitle:\"Senior Manager\", phoneNumber: \"415-555-7770\")\nlet employeeSortedArray = [employee4,employee5,employee6,employee7,employee8].sorted(by: <)\nprint(employeeSortedArray.map {$0.lastName})\n//:## Codable\n// Unlike NSCoding, the Codable protocol allows struct and enum besides class\n\nstruct EmployeeCodable: Codable {\n\tlet firstName: String\n\tlet lastName: String\n\tvar jobTitle: String\n\tvar phoneNumber: String\n}\nlet ben = EmployeeCodable(firstName: \"Ben\", lastName: \"Atkins\", jobTitle: \"Font Desk\", phoneNumber: \"1234567\")\nlet jsonEncoder = JSONEncoder()\n// JSON is a list of key/value pairs for web use\nif let jsonData = try? jsonEncoder.encode(ben), let jsonString = String(data: jsonData, encoding: .utf8) {\n\tprint(jsonString)\n}\n// try? jsonEncoder.encode(ben) is a throwing function, meaning that it can return a specific type of error\n// try? allows the returning of an optional value, i.e nil for an error\n//:## Delegate\n// Use delegate to pass information between objects\n// Both the Delegate property and the Implementor conform to the protocol\n/*:\n>Three Part Structure\\\n1\\. Protocol: defines functional requirements and conformance\\\n2\\. Source: source of information, also calls the method\\\n3\\. Implementor: defines the method code\n\n*/\nprotocol HeartRateReceiverDelegate {\t\t\t\t\t\t\t\t\t\t\t\t// Define conformance\n\tfunc heartRateUpdated(to bpm:Int)\n}\n\nclass HeartRateReceiver {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Source class\n\tvar delegate: HeartRateReceiverDelegate?\t\t\t\t\t\t\t\t\t\t// Define Delegate property\n\tvar currentHR: Int? {\n\t\tdidSet {\n\t\t\tif let currentHR = currentHR {\n\t\t\t\tprint(\"DidSet heart rate \\(currentHR).\")\n\t\t\t\tdelegate?.heartRateUpdated(to: currentHR)\t\t\t\t\t\t// Delegate calls method from Implementor\n\t\t\t} else {\n\t\t\t\tprint(\"No heart rate data.\")\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunc startHeartRateMonitoringExample() {\n\t\tfor _ in 1...3 {\n\t\t\tlet randomHR = 60 + Int(arc4random_uniform(UInt32(15)))\n\t\t\tcurrentHR = randomHR\n\t\t\tThread.sleep(forTimeInterval: 2)\n\t\t}\n\t}\n\t// Generates random heart rate\n}\n\nclass HeartRateViewController: UIViewController,HeartRateReceiverDelegate {\t\t\t// Implementor class\n\tvar heartRateLabel: UILabel = UILabel()\n\t\n\tfunc heartRateUpdated(to bpm: Int) {\n\t\theartRateLabel.text = \"\\(bpm)\"\n\t\tprint(\"VC current heart rate \\(bpm).\")\n\t}\n}\n\nlet heartRateReceiver1 = HeartRateReceiver()\nlet heartRateVC1 = HeartRateViewController()\nheartRateReceiver1.delegate = heartRateVC1\t\t\t\t\t\t\t\t\t// Assign Implementor instance to Delegate\nheartRateReceiver1.startHeartRateMonitoringExample()"
    }
  ]
}