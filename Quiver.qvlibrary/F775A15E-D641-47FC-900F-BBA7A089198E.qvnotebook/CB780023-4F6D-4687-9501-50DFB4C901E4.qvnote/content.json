{
  "title": "ADS 006 Struct",
  "cells": [
    {
      "type": "code",
      "language": "swift",
      "data": "struct Person {\t\t\t\t\t\t\t\t// Declaring a struct: Person object\n\tlet name: String\t\t\t\t\t\t// Declaring struct properties/attributes\n\tvar age: Int\n\tvar education: [String]\t\t\t\t\t// Declaring an array\n\t\n\tfunc sayHello() -> String {\t\t\t\t// Declaring an instance method\n\t\treturn \"Hello, my name is \\(name).\"\n\t}\n}\n\nvar person1 = Person(name: \"Dennis Lau\", age: 22, education: [\"DBS\",\"CUHK\"])\t// Declare an instance of Person\nperson1.name\nperson1.education\nperson1.education[1]\nperson1.sayHello()\n\n// When initializing an new instance, Swift requires setting value for all instance properties\n// So either have a default value\nstruct MiscCounter1 {\n\tvar count: Int = 0\n}\nlet counter1 = MiscCounter1()\nlet counter2 = MiscCounter1(count: 10)\nprint(counter1.count)\nprint(counter2.count)\n\n// Or a memberwise initializer will be used, which includes all instance properties\n\nstruct MiscCounter2 {\n\tvar count: Int\n}\n//let counter3 = MiscCounter2()\t\t\t// This will give an error for having no count value\nlet counter3 = MiscCounter2(count: 0)\t// Memberwise initializer\nprint(counter3.count)\n//: ## Custom Initializer\n// If use custom initializer, swift cannot provide a memberwise initializer, so it must be manualy defined\nstruct TemperatureS1 {\n\tvar celsius: Double\n\t\n\tinit(celsius: Double) {\n\t\tself.celsius = celsius\t\t// self the instance with celsius the property = celsius the initializer argument\n\t\t\t\t\t\t\t\t\t// self is necessary here becuase with the same property and parameter name, parameter takes precedence by default\n\t}\n\t\n\tinit(fahrenheit: Double) {\n\t\tcelsius = (fahrenheit - 32) / 9 * 5\n\t}\n\t\n\tinit(kelvin: Double) {\n\t\tcelsius = kelvin - 273.15\n\t}\n}\nlet currentTemperature = TemperatureS1(celsius: 20)\nlet currentTemperatureF = TemperatureS1(fahrenheit: 77)\nlet currentTemperatureK = TemperatureS1(kelvin: 303.15)\nprint(currentTemperature)\nprint(currentTemperatureF)\nprint(currentTemperatureK)\n//:## Instance Method\nstruct Rectangle {\n\tvar width: Double\n\tvar height: Double\n\t\n\tfunc area() -> Double {\n\t\treturn width * height\n\t}\n}\nlet rect1 = Rectangle(width: 2, height: 3)\nrect1.area()\n//:## Mutating Method\nstruct MiscCounter3 {\n\tvar counter: Double = 0.0\n\tmutating func changeCount(_ number: Double) -> Double {\n\t\tcounter += number\n\t\treturn counter\n\t}\n\tfunc addToCount(_ number: Double) -> Double {\n//\t\tcounter += number\t\t\t\t\t\t\t\tThis will not work because counter is not mutable\n\t\treturn counter + number\n\t}\n}\nvar counter4 = MiscCounter3()\n// Consider the diff between the two methods\ncounter4.addToCount(5)\t\t\t// Using this method the counter value is not actually changed\ncounter4.counter\ncounter4.changeCount(5)\t\t\t// This method changes the counter value\ncounter4.counter\n//:## Calculated Property\nstruct TemperatureS2 {\n\tvar celsius: Double\n\tvar fahrenheit: Double {\n\t\treturn celsius * 9 / 5 + 32\n\t}\n\tvar kelvin: Double {\n\t\treturn celsius + 273.15\n\t}\n}\nlet temperature1 = TemperatureS2(celsius: 20)\ntemperature1.fahrenheit\ntemperature1.kelvin\n//:## Custom Init vs Calculated Property\n/*:\n> Custom Initializer: Diff input types, standardized output\\\nCalculated Property: Same input type, calculate to diff output\n*/\n//:## Property Observer\nstruct AirConTemp {\n\tvar temperature: Double {\n\t\twillSet {\n\t\t\tprint(\"About to set to \\(newValue) degrees.\")\n\t\t}\n\t\tdidSet {\n\t\t\tprint(\"Changed temperature from \\(oldValue) to \\(temperature).\")\n\t\t}\n\t}\n}\nvar airCon1 = AirConTemp(temperature: 20)\nairCon1.temperature = 25\nairCon1.temperature = 27\n//: ## Type Properties & Method\n// Use type properties when the property is related to the type, but not a characteristic of an instance of the type\nstruct TemperatureS3 {\n\tstatic var boilingPoint = 100\n}\nlet boilingPoint = TemperatureS3.boilingPoint\n\n// Type method can be used to write code for the type in general instead of an instance, such as changing the value of a type property\n\nstruct User {\n\tvar userName: String\n\tvar email: String\n\tvar age: Int\n\t\n\tstatic var currentUsers: [User] = [user1]\n\t\n\tstatic func logIn(user: User) {\t\t\t\t// static func indicates a type method\n\t\tUser.currentUsers.append(user)\n\t\tfor user in currentUsers {\n\t\t\tprint(user.userName)\n\t\t}\n\t}\n\t\n}\nvar user1 = User(userName: \"Dennis Lau\", email: \"dennis.lau@abc.com\", age: 22)\nvar user2 = User(userName: \"ABC\", email: \"abc@def.com\", age: 20)\nUser.logIn(user: user2)\n\n// Type method does not need an instance to be called\nlet absoluteNum = abs(-123.123)\t\t\t\t\t//abs is a type method of Double\n//: ## Shadowing Self\nstruct TemperatureS4 {\n\tvar celsius: Double\n\t\n\tinit(celsius: Double) {\n\t\tself.celsius = celsius\n\t}\n}\n// an instance of Temp S4 with property celsius (self.celsius) is gotten from the parameter celsium; them having the same name is called shadowing\n//:## Variable Properties\nvar airCon2 = AirConTemp(temperature: 20)\nvar airCon3 = airCon2\n// Values of airCon2 is copied over\nairCon3.temperature = 23\nairCon2.temperature\nairCon3.temperature\n// When defining the AirConTemp struct, temperature is set as a var so that after copying the values are still mutatble\n// Rule of thumb: use let whenever possible to define an instance, and use var when defining the properties of a structure."
    }
  ]
}